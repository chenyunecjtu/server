!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AF_LOCAL	net.h	41;"	d
CLUSTER_NODE_SIZE	redisNode.h	/^		const uint32_t CLUSTER_NODE_SIZE = 256;$/;"	m	namespace:goddard
CONFIG_MAX_LINE	redisConfig.cpp	/^		static const uint32_t CONFIG_MAX_LINE = 1024;$/;"	m	namespace:goddard	file:
CXX	Makefile	/^CXX=g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS= -Wall -g -Wno-deprecated -std=c++0x -Wno-unused-function -shared -fPIC$/;"	m
DICT_ERR	dict.h	40;"	d
DICT_HT_INITIAL_SIZE	dict.h	76;"	d
DICT_NOTUSED	dict.h	43;"	d
DICT_OK	dict.h	39;"	d
HIREDIS_MAJOR	hiredis.h	42;"	d
HIREDIS_MINOR	hiredis.h	43;"	d
HIREDIS_PATCH	hiredis.h	44;"	d
HIREDIS_SONAME	hiredis.h	45;"	d
IsValidNodeIdx	redisCluster.h	/^						bool IsValidNodeIdx(uint32_t idx)$/;"	f	class:goddard::RedisClusterItem
IsValidSlotIdx	redisCluster.h	/^						bool IsValidSlotIdx(uint32_t slot)$/;"	f	class:goddard::RedisClusterItem
KEYTYPE	redisCommon.h	/^		enum KEYTYPE$/;"	g	namespace:goddard
KEY_TYPE_STR_HASH	redisCommon.h	/^		static const char *KEY_TYPE_STR_HASH = "hash";$/;"	m	namespace:goddard
KEY_TYPE_STR_LIST	redisCommon.h	/^		static const char *KEY_TYPE_STR_LIST = "list";$/;"	m	namespace:goddard
KEY_TYPE_STR_NONE	redisCommon.h	/^		static const char *KEY_TYPE_STR_NONE = "none";$/;"	m	namespace:goddard
KEY_TYPE_STR_SET	redisCommon.h	/^		static const char *KEY_TYPE_STR_SET = "set";$/;"	m	namespace:goddard
KEY_TYPE_STR_STRING	redisCommon.h	/^		static const char *KEY_TYPE_STR_STRING = "string";$/;"	m	namespace:goddard
KEY_TYPE_STR_ZSET	redisCommon.h	/^		static const char *KEY_TYPE_STR_ZSET = "zset";$/;"	m	namespace:goddard
LIBFLAGS	Makefile	/^LIBFLAGS= -lpthread$/;"	m
OBJS	Makefile	/^OBJS=$(patsubst .\/%.cpp, .\/%.o, $(wildcard .\/*.cpp))$/;"	m
REDISCLUSTERSTATE	redisNode.h	/^		enum REDISCLUSTERSTATE$/;"	g	namespace:goddard
REDISMODE	redisConfig.h	/^		enum REDISMODE$/;"	g	namespace:goddard
REDISNODEROLE	redisNode.h	/^		enum REDISNODEROLE$/;"	g	namespace:goddard
REDISNODESTATE	redisNode.h	/^		enum REDISNODESTATE$/;"	g	namespace:goddard
REDIS_BLOCK	hiredis.h	49;"	d
REDIS_CLUSTER_DOWN	redisNode.h	/^				REDIS_CLUSTER_DOWN,$/;"	e	enum:goddard::REDISCLUSTERSTATE
REDIS_CLUSTER_FAIL	redisNode.h	/^				REDIS_CLUSTER_FAIL,$/;"	e	enum:goddard::REDISCLUSTERSTATE
REDIS_CLUSTER_ON	redisNode.h	/^				REDIS_CLUSTER_ON,$/;"	e	enum:goddard::REDISCLUSTERSTATE
REDIS_COMMAND_ASKING	redisCluster.cpp	/^		static const char *REDIS_COMMAND_ASKING = "ASKING";$/;"	m	namespace:goddard	file:
REDIS_COMMAND_CLUSTER_SLOTS	redisCluster.cpp	/^		static const char *REDIS_COMMAND_CLUSTER_SLOTS = "CLUSTER SLOTS";$/;"	m	namespace:goddard	file:
REDIS_CONNECTED	hiredis.h	53;"	d
REDIS_CONNECT_RETRIES	hiredis.h	81;"	d
REDIS_CONN_TCP	hiredis.h	/^    REDIS_CONN_TCP,$/;"	e	enum:redisConnectionType
REDIS_CONN_UNIX	hiredis.h	/^    REDIS_CONN_UNIX$/;"	e	enum:redisConnectionType
REDIS_DISCONNECTING	hiredis.h	59;"	d
REDIS_ERR	read.h	37;"	d
REDIS_ERR_EOF	read.h	45;"	d
REDIS_ERR_IO	read.h	44;"	d
REDIS_ERR_OOM	read.h	47;"	d
REDIS_ERR_OTHER	read.h	48;"	d
REDIS_ERR_PROTOCOL	read.h	46;"	d
REDIS_FREEING	hiredis.h	63;"	d
REDIS_IN_CALLBACK	hiredis.h	66;"	d
REDIS_KEEPALIVE_INTERVAL	hiredis.h	77;"	d
REDIS_MONITORING	hiredis.h	72;"	d
REDIS_OFFLINE	redisNode.h	/^				REDIS_OFFLINE,$/;"	e	enum:goddard::REDISNODESTATE
REDIS_OK	read.h	38;"	d
REDIS_ONLINE	redisNode.h	/^				REDIS_ONLINE,$/;"	e	enum:goddard::REDISNODESTATE
REDIS_READER_MAX_BUF	read.h	57;"	d
REDIS_REPLY_ARRAY	read.h	51;"	d
REDIS_REPLY_ERROR	read.h	55;"	d
REDIS_REPLY_INTEGER	read.h	52;"	d
REDIS_REPLY_NIL	read.h	53;"	d
REDIS_REPLY_STATUS	read.h	54;"	d
REDIS_REPLY_STRING	read.h	50;"	d
REDIS_REUSEADDR	hiredis.h	75;"	d
REDIS_ROLE_INVALID	redisNode.h	/^				REDIS_ROLE_INVALID,$/;"	e	enum:goddard::REDISNODEROLE
REDIS_ROLE_MASTER	redisNode.h	/^				REDIS_ROLE_MASTER,$/;"	e	enum:goddard::REDISNODEROLE
REDIS_ROLE_SLAVE	redisNode.h	/^				REDIS_ROLE_SLAVE,$/;"	e	enum:goddard::REDISNODEROLE
REDIS_SUBSCRIBED	hiredis.h	69;"	d
RedisCluster	redisCluster.h	/^						RedisCluster(const RedisConfig *config) : RedisCommon(config)$/;"	f	class:goddard::RedisCluster
RedisCluster	redisCluster.h	/^		class RedisCluster : public RedisCommon$/;"	c	namespace:goddard
RedisClusterItem	redisCluster.h	/^						RedisClusterItem()$/;"	f	class:goddard::RedisClusterItem
RedisClusterItem	redisCluster.h	/^		class RedisClusterItem$/;"	c	namespace:goddard
RedisClusterNode	redisNode.h	/^						RedisClusterNode()$/;"	f	class:goddard::RedisClusterNode
RedisClusterNode	redisNode.h	/^		class RedisClusterNode : public RedisCommonNode$/;"	c	namespace:goddard
RedisCommon	redisCommon.h	/^						RedisCommon(const RedisConfig *config) : _config(config)$/;"	f	class:goddard::RedisCommon
RedisCommon	redisCommon.h	/^		class RedisCommon$/;"	c	namespace:goddard
RedisCommonNode	redisNode.h	/^						RedisCommonNode()$/;"	f	class:goddard::RedisCommonNode
RedisCommonNode	redisNode.h	/^		class RedisCommonNode$/;"	c	namespace:goddard
RedisConfig	redisConfig.h	/^		class RedisConfig$/;"	c	namespace:goddard
RedisSingle	redisSingle.h	/^						RedisSingle(const RedisConfig *config) : RedisCommon(config)$/;"	f	class:goddard::RedisSingle
RedisSingle	redisSingle.h	/^		class RedisSingle : public RedisCommon$/;"	c	namespace:goddard
RedisSlotNode	redisNode.h	/^						RedisSlotNode()$/;"	f	class:goddard::RedisSlotNode
RedisSlotNode	redisNode.h	/^		class RedisSlotNode$/;"	c	namespace:goddard
SDS_HDR	sds.h	83;"	d
SDS_HDR_VAR	sds.h	82;"	d
SDS_LLSTR_SIZE	sds.cpp	428;"	d	file:
SDS_MAX_PREALLOC	sds.h	36;"	d
SDS_TYPE_16	sds.h	77;"	d
SDS_TYPE_32	sds.h	78;"	d
SDS_TYPE_5	sds.h	75;"	d
SDS_TYPE_5_LEN	sds.h	84;"	d
SDS_TYPE_64	sds.h	79;"	d
SDS_TYPE_8	sds.h	76;"	d
SDS_TYPE_BITS	sds.h	81;"	d
SDS_TYPE_MASK	sds.h	80;"	d
SLOT_MAX_MASK	util.h	/^		const uint32_t SLOT_MAX_MASK = 16383;$/;"	m	namespace:goddard
SLOT_MAX_SIZE	redisNode.h	/^		const uint32_t SLOT_MAX_SIZE = SLOT_MAX_MASK + 1;$/;"	m	namespace:goddard
TARGET	Makefile	/^TARGET=libredisclient.so$/;"	m
UNUSED	sds.cpp	1103;"	d	file:
_BSD_SOURCE	fmacros.h	5;"	d
_DEFAULT_SOURCE	fmacros.h	6;"	d
_EL_ADD_READ	async.cpp	44;"	d	file:
_EL_ADD_WRITE	async.cpp	50;"	d	file:
_EL_CLEANUP	async.cpp	56;"	d	file:
_EL_DEL_READ	async.cpp	47;"	d	file:
_EL_DEL_WRITE	async.cpp	53;"	d	file:
_OSX	fmacros.h	22;"	d
_POSIX_C_SOURCE	fmacros.h	14;"	d
_WIN32_HELPER_INCLUDE	win32.h	2;"	d
_XOPEN_SOURCE	fmacros.h	17;"	d
__DICT_H	dict.h	37;"	d
__HIREDIS_ASYNC_H	async.h	33;"	d
__HIREDIS_FMACRO_H	fmacros.h	2;"	d
__HIREDIS_H	hiredis.h	35;"	d
__HIREDIS_READ_H	read.h	34;"	d
__MAX_MSEC	net.cpp	180;"	d	file:
__NET_H	net.h	36;"	d
__REDISCLUSTER_H__	redisCluster.h	20;"	d
__REDISCOMMON_H__	redisCommon.h	20;"	d
__REDISCOMMPROCESS_H__	redisCommProcess.h	20;"	d
__REDISCONFIG_H__	redisConfig.h	20;"	d
__REDISNODE_H__	redisNode.h	20;"	d
__REDISSINGLE_H__	redisSingle.h	22;"	d
__SDS_H	sds.h	34;"	d
__UTIL_H_	util.h	20;"	d
__redisAppendCommand	hiredis.cpp	/^int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {$/;"	f
__redisAsyncCommand	async.cpp	/^static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {$/;"	f	file:
__redisAsyncCopyError	async.cpp	/^static void __redisAsyncCopyError(redisAsyncContext *ac) {$/;"	f	file:
__redisAsyncDisconnect	async.cpp	/^static void __redisAsyncDisconnect(redisAsyncContext *ac) {$/;"	f	file:
__redisAsyncFree	async.cpp	/^static void __redisAsyncFree(redisAsyncContext *ac) {$/;"	f	file:
__redisAsyncHandleConnect	async.cpp	/^static int __redisAsyncHandleConnect(redisAsyncContext *ac) {$/;"	f	file:
__redisBlockForReply	hiredis.cpp	/^static void *__redisBlockForReply(redisContext *c) {$/;"	f	file:
__redisGetSubscribeCallback	async.cpp	/^static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply, redisCallback *dstcb) {$/;"	f	file:
__redisPushCallback	async.cpp	/^static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {$/;"	f	file:
__redisReaderSetError	read.cpp	/^static void __redisReaderSetError(redisReader *r, int type, const char *str) {$/;"	f	file:
__redisReaderSetErrorOOM	read.cpp	/^static void __redisReaderSetErrorOOM(redisReader *r) {$/;"	f	file:
__redisReaderSetErrorProtocolByte	read.cpp	/^static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {$/;"	f	file:
__redisRunCallback	async.cpp	/^static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisReply *reply) {$/;"	f	file:
__redisSetError	hiredis.cpp	/^void __redisSetError(redisContext *c, int type, const char *str) {$/;"	f
__redisSetErrorFromErrno	net.cpp	/^static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {$/;"	f	file:
__redisShiftCallback	async.cpp	/^static int __redisShiftCallback(redisCallbackList *list, redisCallback *target) {$/;"	f	file:
__redis_strerror_r	hiredis.h	88;"	d
__redis_strerror_r	hiredis.h	94;"	d
_clusterNodeArray	redisCluster.h	/^						RedisClusterNode _clusterNodeArray[CLUSTER_NODE_SIZE];$/;"	m	class:goddard::RedisClusterItem
_config	redisCommon.h	/^						const RedisConfig *_config;$/;"	m	class:goddard::RedisCommon
_config	redisConfig.h	/^						stRedisConfigItem _config;$/;"	m	class:goddard::RedisConfig
_ctx	redisNode.h	/^						redisContext *_ctx;$/;"	m	class:goddard::RedisCommonNode
_dictClear	dict.c	/^static int _dictClear(dict *ht) {$/;"	f	file:
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *ht) {$/;"	f	file:
_dictInit	dict.c	/^static int _dictInit(dict *ht, dictType *type, void *privDataPtr) {$/;"	f	file:
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *ht, const void *key) {$/;"	f	file:
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size) {$/;"	f	file:
_dictReset	dict.c	/^static void _dictReset(dict *ht) {$/;"	f	file:
_id	redisNode.h	/^						uint32_t _id;$/;"	m	class:goddard::RedisCommonNode
_ip	redisConfig.h	/^				std::string _ip;$/;"	m	struct:goddard::stRedisConfigItem
_ip	redisNode.h	/^						std::string _ip;$/;"	m	class:goddard::RedisCommonNode
_master_count	redisCommon.h	/^						uint32_t _master_count;$/;"	m	class:goddard::RedisCommon
_mode	redisConfig.h	/^				REDISMODE _mode;$/;"	m	struct:goddard::stRedisConfigItem
_node	redisNode.h	/^						RedisClusterNode *_node;$/;"	m	class:goddard::RedisSlotNode
_owner	redisCluster.h	/^						RedisCluster *_owner;$/;"	m	class:goddard::RedisClusterItem
_owner	redisNode.h	/^						RedisCommon *_owner;$/;"	m	class:goddard::RedisCommonNode
_passwd	redisConfig.h	/^				std::string _passwd;$/;"	m	struct:goddard::stRedisConfigItem
_passwd	redisNode.h	/^						std::string _passwd;$/;"	m	class:goddard::RedisCommonNode
_port	redisConfig.h	/^				uint16_t _port;$/;"	m	struct:goddard::stRedisConfigItem
_port	redisNode.h	/^						uint32_t _port;$/;"	m	class:goddard::RedisCommonNode
_redirectCount	redisCluster.h	/^						uint32_t _redirectCount;$/;"	m	class:goddard::RedisCluster
_redisContextConnectTcp	net.cpp	/^static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,$/;"	f	file:
_slave_count	redisCommon.h	/^						uint32_t _slave_count;$/;"	m	class:goddard::RedisCommon
_slot	redisNode.h	/^						uint32_t _slot;$/;"	m	class:goddard::RedisSlotNode
_slotArray	redisCluster.h	/^						RedisSlotNode _slotArray[SLOT_MAX_SIZE];$/;"	m	class:goddard::RedisClusterItem
_timeout	redisConfig.h	/^				struct timeval _timeout;$/;"	m	struct:goddard::stRedisConfigItem	typeref:struct:goddard::stRedisConfigItem::timeval
addRead	async.h	/^        void (*addRead)(void *privdata);$/;"	m	struct:redisAsyncContext::__anon1
addSlaveNode	redisNode.cpp	/^		bool RedisCommonNode::addSlaveNode(const std::string &ip, uint32_t port, const struct timeval timeout)$/;"	f	class:goddard::RedisCommonNode
addWrite	async.h	/^        void (*addWrite)(void *privdata);$/;"	m	struct:redisAsyncContext::__anon1
alloc	sds.h	/^    uint16_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr16
alloc	sds.h	/^    uint32_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr32
alloc	sds.h	/^    uint64_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr64
alloc	sds.h	/^    uint8_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr8
ap	redisCommProcess.h	/^				va_list ap;$/;"	m	struct:goddard::cmd_st
buf	read.h	/^    char *buf; \/* Read buffer *\/$/;"	m	struct:redisReader
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr16
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr32
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr5
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr64
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr8
bulklen	hiredis.cpp	/^static size_t bulklen(size_t len) {$/;"	f	file:
c	async.h	/^    redisContext c;$/;"	m	struct:redisAsyncContext
c99_snprintf	win32.h	/^__inline int c99_snprintf(char* str, size_t size, const char* format, ...)$/;"	f
c99_vsnprintf	win32.h	/^__inline int c99_vsnprintf(char* str, size_t size, const char* format, va_list ap)$/;"	f
callbackDict	async.cpp	/^static dictType callbackDict = {$/;"	v	file:
callbackHash	async.cpp	/^static unsigned int callbackHash(const void *key) {$/;"	f	file:
callbackKeyCompare	async.cpp	/^static int callbackKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f	file:
callbackKeyDestructor	async.cpp	/^static void callbackKeyDestructor(void *privdata, void *key) {$/;"	f	file:
callbackValDestructor	async.cpp	/^static void callbackValDestructor(void *privdata, void *val) {$/;"	f	file:
callbackValDup	async.cpp	/^static void *callbackValDup(void *privdata, const void *src) {$/;"	f	file:
channels	async.h	/^        struct dict *channels;$/;"	m	struct:redisAsyncContext::__anon2	typeref:struct:redisAsyncContext::__anon2::dict
chrtos	read.cpp	/^static size_t chrtos(char *buf, size_t size, char byte) {$/;"	f	file:
cleanup	async.h	/^        void (*cleanup)(void *privdata);$/;"	m	struct:redisAsyncContext::__anon1
clearSlot	redisNode.h	/^						void clearSlot(const uint32_t slot)$/;"	f	class:goddard::RedisClusterNode
clusterRefresh	redisCluster.cpp	/^		bool RedisCluster::clusterRefresh()$/;"	f	class:goddard::RedisCluster
clusterRefreshFromReply	redisCluster.cpp	/^		bool RedisCluster::clusterRefreshFromReply(const redisReply *reply)$/;"	f	class:goddard::RedisCluster
cmd_st	redisCommProcess.h	/^		struct cmd_st$/;"	s	namespace:goddard
commandClusterSlots	redisCluster.cpp	/^		redisReply * RedisCluster::commandClusterSlots(redisContext *ctx)$/;"	f	class:goddard::RedisCluster
connNodeSlot	redisCluster.h	/^						void connNodeSlot(RedisClusterNode *node, uint32_t slot)$/;"	f	class:goddard::RedisClusterItem
connNodeSlot	redisNode.h	/^						void connNodeSlot(RedisClusterNode *node, uint32_t slot)$/;"	f	class:goddard::RedisSlotNode
connection_type	hiredis.h	/^    enum redisConnectionType connection_type;$/;"	m	struct:redisContext	typeref:enum:redisContext::redisConnectionType
countDigits	hiredis.cpp	/^static uint32_t countDigits(uint64_t v) {$/;"	f	file:
crc16	util.cpp	/^		uint16_t crc16(const char *buf, int len) {$/;"	f	namespace:goddard
crc16tab	util.cpp	/^		static const uint16_t crc16tab[256]= {$/;"	m	namespace:goddard	file:
createArray	read.h	/^    void *(*createArray)(const redisReadTask*, int);$/;"	m	struct:redisReplyObjectFunctions
createArrayObject	hiredis.cpp	/^static void *createArrayObject(const redisReadTask *task, int elements) {$/;"	f	file:
createInteger	read.h	/^    void *(*createInteger)(const redisReadTask*, long long);$/;"	m	struct:redisReplyObjectFunctions
createIntegerObject	hiredis.cpp	/^static void *createIntegerObject(const redisReadTask *task, long long value) {$/;"	f	file:
createNil	read.h	/^    void *(*createNil)(const redisReadTask*);$/;"	m	struct:redisReplyObjectFunctions
createNilObject	hiredis.cpp	/^static void *createNilObject(const redisReadTask *task) {$/;"	f	file:
createReplyObject	hiredis.cpp	/^static redisReply *createReplyObject(int type) {$/;"	f	file:
createString	read.h	/^    void *(*createString)(const redisReadTask*, char*, size_t);$/;"	m	struct:redisReplyObjectFunctions
createStringObject	hiredis.cpp	/^static void *createStringObject(const redisReadTask *task, char *str, size_t len) {$/;"	f	file:
data	async.h	/^        void *data;$/;"	m	struct:redisAsyncContext::__anon1
data	async.h	/^    void *data;$/;"	m	struct:redisAsyncContext
decrMasterCount	redisCommon.h	/^						void decrMasterCount()$/;"	f	class:goddard::RedisCommon
decrSlaveCount	redisCommon.h	/^						void decrSlaveCount()$/;"	f	class:goddard::RedisCommon
defaultFunctions	hiredis.cpp	/^static redisReplyObjectFunctions defaultFunctions = {$/;"	v	file:
delRead	async.h	/^        void (*delRead)(void *privdata);$/;"	m	struct:redisAsyncContext::__anon1
delWrite	async.h	/^        void (*delWrite)(void *privdata);$/;"	m	struct:redisAsyncContext::__anon1
dict	dict.h	/^typedef struct dict {$/;"	s
dict	dict.h	/^} dict;$/;"	t	typeref:struct:dict
dictAdd	dict.c	/^static int dictAdd(dict *ht, void *key, void *val) {$/;"	f	file:
dictCompareHashKeys	dict.h	101;"	d
dictCreate	dict.c	/^static dict *dictCreate(dictType *type, void *privDataPtr) {$/;"	f	file:
dictDelete	dict.c	/^static int dictDelete(dict *ht, const void *key) {$/;"	f	file:
dictEntry	dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictExpand	dict.c	/^static int dictExpand(dict *ht, unsigned long size) {$/;"	f	file:
dictFind	dict.c	/^static dictEntry *dictFind(dict *ht, const void *key) {$/;"	f	file:
dictFreeEntryKey	dict.h	90;"	d
dictFreeEntryVal	dict.h	79;"	d
dictGenHashFunction	dict.c	/^static unsigned int dictGenHashFunction(const unsigned char *buf, int len) {$/;"	f	file:
dictGetEntryKey	dict.h	108;"	d
dictGetEntryVal	dict.h	109;"	d
dictGetIterator	dict.c	/^static dictIterator *dictGetIterator(dict *ht) {$/;"	f	file:
dictHashKey	dict.h	106;"	d
dictIterator	dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictNext	dict.c	/^static dictEntry *dictNext(dictIterator *iter) {$/;"	f	file:
dictRelease	dict.c	/^static void dictRelease(dict *ht) {$/;"	f	file:
dictReleaseIterator	dict.c	/^static void dictReleaseIterator(dictIterator *iter) {$/;"	f	file:
dictReplace	dict.c	/^static int dictReplace(dict *ht, void *key, void *val) {$/;"	f	file:
dictSetHashKey	dict.h	94;"	d
dictSetHashVal	dict.h	83;"	d
dictSize	dict.h	111;"	d
dictSlots	dict.h	110;"	d
dictType	dict.h	/^typedef struct dictType {$/;"	s
dictType	dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
disconnNodeSlot	redisCluster.cpp	/^		void RedisCluster::disconnNodeSlot(RedisClusterNode *node, uint32_t slot)$/;"	f	class:goddard::RedisCluster
disconnNodeSlot	redisCluster.h	/^						void disconnNodeSlot(RedisClusterNode *node, uint32_t slot)$/;"	f	class:goddard::RedisClusterItem
disconnNodeSlot	redisNode.h	/^						void disconnNodeSlot(RedisClusterNode *node, uint32_t slot)$/;"	f	class:goddard::RedisSlotNode
eHash	redisCommon.h	/^				eHash,$/;"	e	enum:goddard::KEYTYPE
eList	redisCommon.h	/^				eList,$/;"	e	enum:goddard::KEYTYPE
eNone	redisCommon.h	/^				eNone,$/;"	e	enum:goddard::KEYTYPE
eRedisCluster	redisConfig.h	/^				eRedisCluster,$/;"	e	enum:goddard::REDISMODE
eRedisInvalid	redisConfig.h	/^				eRedisInvalid,$/;"	e	enum:goddard::REDISMODE
eRedisSingle	redisConfig.h	/^				eRedisSingle,$/;"	e	enum:goddard::REDISMODE
eRole	redisNode.h	/^						enum REDISNODEROLE eRole;$/;"	m	class:goddard::RedisCommonNode	typeref:enum:goddard::RedisCommonNode::REDISNODEROLE
eSet	redisCommon.h	/^				eSet,$/;"	e	enum:goddard::KEYTYPE
eState	redisCluster.h	/^						enum REDISCLUSTERSTATE eState;$/;"	m	class:goddard::RedisClusterItem	typeref:enum:goddard::RedisClusterItem::REDISCLUSTERSTATE
eState	redisNode.h	/^						enum REDISNODESTATE eState;$/;"	m	class:goddard::RedisCommonNode	typeref:enum:goddard::RedisCommonNode::REDISNODESTATE
eString	redisCommon.h	/^				eString,$/;"	e	enum:goddard::KEYTYPE
eZSet	redisCommon.h	/^				eZSet,$/;"	e	enum:goddard::KEYTYPE
element	hiredis.h	/^    struct redisReply **element; \/* elements vector for REDIS_REPLY_ARRAY *\/$/;"	m	struct:redisReply	typeref:struct:redisReply::redisReply
elements	hiredis.h	/^    size_t elements; \/* number of elements, for REDIS_REPLY_ARRAY *\/$/;"	m	struct:redisReply
elements	read.h	/^    int elements; \/* number of elements in multibulk container *\/$/;"	m	struct:redisReadTask
entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
err	async.h	/^    int err;$/;"	m	struct:redisAsyncContext
err	hiredis.h	/^    int err; \/* Error flags, 0 when there is no error *\/$/;"	m	struct:redisContext
err	read.h	/^    int err; \/* Error flags, 0 when there is no error *\/$/;"	m	struct:redisReader
errstr	async.h	/^    char *errstr;$/;"	m	struct:redisAsyncContext
errstr	hiredis.h	/^    char errstr[128]; \/* String representation of error when applicable *\/$/;"	m	struct:redisContext
errstr	read.h	/^    char errstr[128]; \/* String representation of error when applicable *\/$/;"	m	struct:redisReader
ev	async.h	/^    } ev;$/;"	m	struct:redisAsyncContext	typeref:struct:redisAsyncContext::__anon1
fd	hiredis.h	/^    int fd;$/;"	m	struct:redisContext
fetchOneConfigArgv	redisConfig.cpp	/^		bool RedisConfig::fetchOneConfigArgv(uint32_t argc, sds *argv)$/;"	f	class:goddard::RedisConfig
flags	hiredis.h	/^    int flags;$/;"	m	struct:redisContext
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr16
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr32
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr64
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr8
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, and 5 msb of string length *\/$/;"	m	struct:sdshdr5
fn	async.h	/^    redisCallbackFn *fn;$/;"	m	struct:redisCallback
fn	read.h	/^    redisReplyObjectFunctions *fn;$/;"	m	struct:redisReader
format	redisCommProcess.h	/^				const char *format;$/;"	m	struct:goddard::cmd_st
freeObject	read.h	/^    void (*freeObject)(void*);$/;"	m	struct:redisReplyObjectFunctions
freeReplyObject	hiredis.cpp	/^void freeReplyObject(void *reply) {$/;"	f
getClusterNodeBySlotIdx	redisCluster.cpp	/^		RedisClusterNode* RedisClusterItem::getClusterNodeBySlotIdx(uint32_t slot)$/;"	f	class:goddard::RedisClusterItem
getCtx	redisNode.h	/^						redisContext *getCtx()$/;"	f	class:goddard::RedisCommonNode
getFreeNode	redisCluster.cpp	/^		RedisClusterNode *RedisClusterItem::getFreeNode()$/;"	f	class:goddard::RedisClusterItem
getIP	redisCommon.h	/^						const char *getIP() const$/;"	f	class:goddard::RedisCommon
getIP	redisConfig.h	/^						const char *getIP() const$/;"	f	class:goddard::RedisConfig
getIP	redisNode.h	/^						const std::string& getIP()$/;"	f	class:goddard::RedisCommonNode
getMasterCount	redisCommon.h	/^						uint32_t getMasterCount()$/;"	f	class:goddard::RedisCommon
getMasterNode	redisCluster.cpp	/^		RedisClusterNode* RedisClusterItem::getMasterNode(const std::string &ip, const uint32_t &port)$/;"	f	class:goddard::RedisClusterItem
getMode	redisConfig.h	/^						REDISMODE getMode() const$/;"	f	class:goddard::RedisConfig
getNode	redisNode.h	/^						RedisClusterNode *getNode()$/;"	f	class:goddard::RedisSlotNode
getNodeByIdx	redisCluster.h	/^						RedisClusterNode* getNodeByIdx(uint32_t idx)$/;"	f	class:goddard::RedisClusterItem
getPasswd	redisCommon.h	/^						const std::string& getPasswd() const$/;"	f	class:goddard::RedisCommon
getPasswd	redisConfig.h	/^						const std::string& getPasswd() const$/;"	f	class:goddard::RedisConfig
getPort	redisCommon.h	/^						uint32_t getPort() const$/;"	f	class:goddard::RedisCommon
getPort	redisConfig.h	/^						uint16_t getPort() const$/;"	f	class:goddard::RedisConfig
getPort	redisNode.h	/^						uint32_t getPort()$/;"	f	class:goddard::RedisCommonNode
getRedisNode	redisCluster.cpp	/^		RedisCommonNode *RedisCluster::getRedisNode(const char *key)$/;"	f	class:goddard::RedisCluster
getRedisNode	redisSingle.h	/^						virtual RedisCommonNode* getRedisNode(const char *key)$/;"	f	class:goddard::RedisSingle
getSlaveCount	redisCommon.h	/^						uint32_t getSlaveCount()$/;"	f	class:goddard::RedisCommon
getSlaveNode	redisNode.cpp	/^		RedisCommonNode * RedisCommonNode::getSlaveNode(const std::string &ip, const uint32_t &port)$/;"	f	class:goddard::RedisCommonNode
getSlot	redisNode.h	/^						uint32_t getSlot()$/;"	f	class:goddard::RedisSlotNode
getTimeout	redisCommon.h	/^						struct timeval getTimeout() const$/;"	f	class:goddard::RedisCommon
getTimeout	redisConfig.h	/^						struct timeval getTimeout() const$/;"	f	class:goddard::RedisConfig
goddard	redisCluster.cpp	/^namespace goddard$/;"	n	file:
goddard	redisCluster.h	/^namespace goddard$/;"	n
goddard	redisCommProcess.h	/^namespace goddard$/;"	n
goddard	redisCommon.h	/^namespace goddard$/;"	n
goddard	redisConfig.cpp	/^namespace goddard$/;"	n	file:
goddard	redisConfig.h	/^namespace goddard$/;"	n
goddard	redisNode.cpp	/^namespace goddard$/;"	n	file:
goddard	redisNode.h	/^namespace goddard$/;"	n
goddard	redisSingle.h	/^namespace goddard$/;"	n
goddard	util.cpp	/^namespace goddard$/;"	n	file:
goddard	util.h	/^namespace goddard$/;"	n
hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType
head	async.h	/^    redisCallback *head, *tail;$/;"	m	struct:redisCallbackList
hex_digit_to_int	sds.cpp	/^int hex_digit_to_int(char c) {$/;"	f
host	hiredis.h	/^        char *host;$/;"	m	struct:redisContext::__anon3
ht	dict.h	/^    dict *ht;$/;"	m	struct:dictIterator
idx	read.h	/^    int idx; \/* index in parent (array) object *\/$/;"	m	struct:redisReadTask
incrMasterCount	redisCommon.h	/^						void incrMasterCount()$/;"	f	class:goddard::RedisCommon
incrSlaveCount	redisCommon.h	/^						void incrSlaveCount()$/;"	f	class:goddard::RedisCommon
index	dict.h	/^    int index;$/;"	m	struct:dictIterator
init	redisConfig.cpp	/^		bool RedisConfig::init(const std::string &fileName)$/;"	f	class:goddard::RedisConfig
inline	win32.h	6;"	d
integer	hiredis.h	/^    long long integer; \/* The integer when type is REDIS_REPLY_INTEGER *\/$/;"	m	struct:redisReply
invalid	async.h	/^        redisCallbackList invalid;$/;"	m	struct:redisAsyncContext::__anon2
ireply	redisCommProcess.h	/^				redisReply *ireply;$/;"	m	struct:goddard::cmd_st
isOnline	redisNode.h	/^						bool isOnline()$/;"	f	class:goddard::RedisCommonNode
is_hex_digit	sds.cpp	/^int is_hex_digit(char c) {$/;"	f
key	dict.h	/^    void *key;$/;"	m	struct:dictEntry
keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType
keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType
keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType
len	hiredis.h	/^    size_t len; \/* Length of string *\/$/;"	m	struct:redisReply
len	read.h	/^    size_t len; \/* Buffer length *\/$/;"	m	struct:redisReader
len	sds.h	/^    uint16_t len; \/* used *\/$/;"	m	struct:sdshdr16
len	sds.h	/^    uint32_t len; \/* used *\/$/;"	m	struct:sdshdr32
len	sds.h	/^    uint64_t len; \/* used *\/$/;"	m	struct:sdshdr64
len	sds.h	/^    uint8_t len; \/* used *\/$/;"	m	struct:sdshdr8
loadConfig	redisConfig.cpp	/^		bool RedisConfig::loadConfig(const std::string &fileName)$/;"	f	class:goddard::RedisConfig
loadConfigFromString	redisConfig.cpp	/^		bool RedisConfig::loadConfigFromString(const char *config)$/;"	f	class:goddard::RedisConfig
mCluster	redisCluster.h	/^						RedisClusterItem mCluster;$/;"	m	class:goddard::RedisCluster
mNode	redisSingle.h	/^						RedisCommonNode mNode;$/;"	m	class:goddard::RedisSingle
main	sds.cpp	/^int main(void) {$/;"	f
maxbuf	read.h	/^    size_t maxbuf; \/* Max length of unused buffer *\/$/;"	m	struct:redisReader
moveToNextTask	read.cpp	/^static void moveToNextTask(redisReader *r) {$/;"	f	file:
newInstance	redisNode.h	/^						virtual RedisCommonNode* newInstance()$/;"	f	class:goddard::RedisClusterNode
newInstance	redisNode.h	/^						virtual RedisCommonNode* newInstance()$/;"	f	class:goddard::RedisCommonNode
next	async.h	/^    struct redisCallback *next; \/* simple singly linked list *\/$/;"	m	struct:redisCallback	typeref:struct:redisCallback::redisCallback
next	dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry
nextArgument	async.cpp	/^static const char *nextArgument(const char *start, const char **str, size_t *len) {$/;"	f	file:
nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
node	redisCommProcess.h	/^				RedisCommonNode *node;$/;"	m	struct:goddard::cmd_st
nodeOnline	redisCluster.h	/^						bool nodeOnline(uint32_t idx, const timeval &timeout, REDISNODEROLE role)$/;"	f	class:goddard::RedisClusterItem
nodeReset	redisCluster.h	/^						bool nodeReset(uint32_t idx, const std::string &ip, const uint32_t port)$/;"	f	class:goddard::RedisClusterItem
obj	read.h	/^    void *obj; \/* holds user-generated value for a read task *\/$/;"	m	struct:redisReadTask
obuf	hiredis.h	/^    char *obuf; \/* Write buffer *\/$/;"	m	struct:redisContext
onConnect	async.h	/^    redisConnectCallback *onConnect;$/;"	m	struct:redisAsyncContext
onDisconnect	async.h	/^    redisDisconnectCallback *onDisconnect;$/;"	m	struct:redisAsyncContext
online	redisCluster.h	/^						void online()$/;"	f	class:goddard::RedisClusterItem
online	redisNode.cpp	/^		bool RedisCommonNode::online(const struct timeval &timeout, const REDISNODEROLE role)$/;"	f	class:goddard::RedisCommonNode
oreply	redisCommProcess.h	/^				redisReply *oreply;$/;"	m	struct:goddard::cmd_st
parent	read.h	/^    struct redisReadTask *parent; \/* parent task *\/$/;"	m	struct:redisReadTask	typeref:struct:redisReadTask::redisReadTask
parseConfigLine	redisConfig.cpp	/^		sds *RedisConfig::parseConfigLine(const char *line, uint32_t *argc)$/;"	f	class:goddard::RedisConfig
path	hiredis.h	/^        char *path;$/;"	m	struct:redisContext::__anon4
patterns	async.h	/^        struct dict *patterns;$/;"	m	struct:redisAsyncContext::__anon2	typeref:struct:redisAsyncContext::__anon2::dict
port	hiredis.h	/^        int port;$/;"	m	struct:redisContext::__anon3
pos	read.h	/^    size_t pos; \/* Buffer cursor *\/$/;"	m	struct:redisReader
print_error	util.h	33;"	d
privdata	async.h	/^    void *privdata;$/;"	m	struct:redisCallback
privdata	dict.h	/^    void *privdata;$/;"	m	struct:dict
privdata	read.h	/^    void *privdata; \/* user-settable arbitrary field *\/$/;"	m	struct:redisReadTask
privdata	read.h	/^    void *privdata;$/;"	m	struct:redisReader
processBulkItem	read.cpp	/^static int processBulkItem(redisReader *r) {$/;"	f	file:
processItem	read.cpp	/^static int processItem(redisReader *r) {$/;"	f	file:
processLineItem	read.cpp	/^static int processLineItem(redisReader *r) {$/;"	f	file:
processMovedAsk	redisCluster.cpp	/^		bool RedisCluster::processMovedAsk(cmd_st *cmd, bool isAsk)$/;"	f	class:goddard::RedisCluster
processMultiBulkItem	read.cpp	/^static int processMultiBulkItem(redisReader *r) {$/;"	f	file:
readBytes	read.cpp	/^static char *readBytes(redisReader *r, unsigned int bytes) {$/;"	f	file:
readLine	read.cpp	/^static char *readLine(redisReader *r, int *_len) {$/;"	f	file:
readLongLong	read.cpp	/^static long long readLongLong(char *s) {$/;"	f	file:
reader	hiredis.h	/^    redisReader *reader; \/* Protocol reader *\/$/;"	m	struct:redisContext
redis	redisCommProcess.h	/^				RedisCommon *redis;$/;"	m	struct:goddard::cmd_st
redisAppendCommand	hiredis.cpp	/^int redisAppendCommand(redisContext *c, const char *format, ...) {$/;"	f
redisAppendCommandArgv	hiredis.cpp	/^int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {$/;"	f
redisAppendFormattedCommand	hiredis.cpp	/^int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {$/;"	f
redisAsyncCommand	async.cpp	/^int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...) {$/;"	f
redisAsyncCommandArgv	async.cpp	/^int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen) {$/;"	f
redisAsyncConnect	async.cpp	/^redisAsyncContext *redisAsyncConnect(const char *ip, int port) {$/;"	f
redisAsyncConnectBind	async.cpp	/^redisAsyncContext *redisAsyncConnectBind(const char *ip, int port,$/;"	f
redisAsyncConnectBindWithReuse	async.cpp	/^redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,$/;"	f
redisAsyncConnectUnix	async.cpp	/^redisAsyncContext *redisAsyncConnectUnix(const char *path) {$/;"	f
redisAsyncContext	async.h	/^typedef struct redisAsyncContext {$/;"	s
redisAsyncContext	async.h	/^} redisAsyncContext;$/;"	t	typeref:struct:redisAsyncContext
redisAsyncDisconnect	async.cpp	/^void redisAsyncDisconnect(redisAsyncContext *ac) {$/;"	f
redisAsyncFormattedCommand	async.cpp	/^int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {$/;"	f
redisAsyncFree	async.cpp	/^void redisAsyncFree(redisAsyncContext *ac) {$/;"	f
redisAsyncHandleRead	async.cpp	/^void redisAsyncHandleRead(redisAsyncContext *ac) {$/;"	f
redisAsyncHandleWrite	async.cpp	/^void redisAsyncHandleWrite(redisAsyncContext *ac) {$/;"	f
redisAsyncInitialize	async.cpp	/^static redisAsyncContext *redisAsyncInitialize(redisContext *c) {$/;"	f	file:
redisAsyncSetConnectCallback	async.cpp	/^int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn) {$/;"	f
redisAsyncSetDisconnectCallback	async.cpp	/^int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn) {$/;"	f
redisBufferRead	hiredis.cpp	/^int redisBufferRead(redisContext *c) {$/;"	f
redisBufferWrite	hiredis.cpp	/^int redisBufferWrite(redisContext *c, int *done) {$/;"	f
redisCallback	async.h	/^typedef struct redisCallback {$/;"	s
redisCallback	async.h	/^} redisCallback;$/;"	t	typeref:struct:redisCallback
redisCallbackFn	async.h	/^typedef void (redisCallbackFn)(struct redisAsyncContext*, void*, void*);$/;"	t
redisCallbackList	async.h	/^typedef struct redisCallbackList {$/;"	s
redisCallbackList	async.h	/^} redisCallbackList;$/;"	t	typeref:struct:redisCallbackList
redisCheckSocketError	net.cpp	/^int redisCheckSocketError(redisContext *c) {$/;"	f
redisCommand	hiredis.cpp	/^void *redisCommand(redisContext *c, const char *format, ...) {$/;"	f
redisCommandArgv	hiredis.cpp	/^void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {$/;"	f
redisConnect	hiredis.cpp	/^redisContext *redisConnect(const char *ip, int port) {$/;"	f
redisConnectBindNonBlock	hiredis.cpp	/^redisContext *redisConnectBindNonBlock(const char *ip, int port,$/;"	f
redisConnectBindNonBlockWithReuse	hiredis.cpp	/^redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,$/;"	f
redisConnectCallback	async.h	/^typedef void (redisConnectCallback)(const struct redisAsyncContext*, int status);$/;"	t
redisConnectFd	hiredis.cpp	/^redisContext *redisConnectFd(int fd) {$/;"	f
redisConnectNonBlock	hiredis.cpp	/^redisContext *redisConnectNonBlock(const char *ip, int port) {$/;"	f
redisConnectUnix	hiredis.cpp	/^redisContext *redisConnectUnix(const char *path) {$/;"	f
redisConnectUnixNonBlock	hiredis.cpp	/^redisContext *redisConnectUnixNonBlock(const char *path) {$/;"	f
redisConnectUnixWithTimeout	hiredis.cpp	/^redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {$/;"	f
redisConnectWithTimeout	hiredis.cpp	/^redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {$/;"	f
redisConnectionType	hiredis.h	/^enum redisConnectionType {$/;"	g
redisContext	hiredis.h	/^typedef struct redisContext {$/;"	s
redisContext	hiredis.h	/^} redisContext;$/;"	t	typeref:struct:redisContext
redisContextCloseFd	net.cpp	/^static void redisContextCloseFd(redisContext *c) {$/;"	f	file:
redisContextConnectBindTcp	net.cpp	/^int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,$/;"	f
redisContextConnectTcp	net.cpp	/^int redisContextConnectTcp(redisContext *c, const char *addr, int port,$/;"	f
redisContextConnectUnix	net.cpp	/^int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {$/;"	f
redisContextInit	hiredis.cpp	/^static redisContext *redisContextInit(void) {$/;"	f	file:
redisContextSetTimeout	net.cpp	/^int redisContextSetTimeout(redisContext *c, const struct timeval tv) {$/;"	f
redisContextTimeoutMsec	net.cpp	/^static int redisContextTimeoutMsec(redisContext *c, long *result)$/;"	f	file:
redisContextWaitReady	net.cpp	/^static int redisContextWaitReady(redisContext *c, long msec) {$/;"	f	file:
redisCreateSocket	net.cpp	/^static int redisCreateSocket(redisContext *c, int type) {$/;"	f	file:
redisDisconnectCallback	async.h	/^typedef void (redisDisconnectCallback)(const struct redisAsyncContext*, int status);$/;"	t
redisEnableKeepAlive	hiredis.cpp	/^int redisEnableKeepAlive(redisContext *c) {$/;"	f
redisFormatCommand	hiredis.cpp	/^int redisFormatCommand(char **target, const char *format, ...) {$/;"	f
redisFormatCommandArgv	hiredis.cpp	/^int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {$/;"	f
redisFormatSdsCommandArgv	hiredis.cpp	/^int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,$/;"	f
redisFree	hiredis.cpp	/^void redisFree(redisContext *c) {$/;"	f
redisFreeCommand	hiredis.cpp	/^void redisFreeCommand(char *cmd) {$/;"	f
redisFreeKeepFd	hiredis.cpp	/^int redisFreeKeepFd(redisContext *c) {$/;"	f
redisFreeSdsCommand	hiredis.cpp	/^void redisFreeSdsCommand(sds cmd) {$/;"	f
redisGetReply	hiredis.cpp	/^int redisGetReply(redisContext *c, void **reply) {$/;"	f
redisGetReplyFromReader	hiredis.cpp	/^int redisGetReplyFromReader(redisContext *c, void **reply) {$/;"	f
redisKeepAlive	net.cpp	/^int redisKeepAlive(redisContext *c, int interval) {$/;"	f
redisProcessCallbacks	async.cpp	/^void redisProcessCallbacks(redisAsyncContext *ac) {$/;"	f
redisReadTask	read.h	/^typedef struct redisReadTask {$/;"	s
redisReadTask	read.h	/^} redisReadTask;$/;"	t	typeref:struct:redisReadTask
redisReader	read.h	/^typedef struct redisReader {$/;"	s
redisReader	read.h	/^} redisReader;$/;"	t	typeref:struct:redisReader
redisReaderCreate	hiredis.cpp	/^redisReader *redisReaderCreate(void) {$/;"	f
redisReaderCreateWithFunctions	read.cpp	/^redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {$/;"	f
redisReaderFeed	read.cpp	/^int redisReaderFeed(redisReader *r, const char *buf, size_t len) {$/;"	f
redisReaderFree	read.cpp	/^void redisReaderFree(redisReader *r) {$/;"	f
redisReaderGetError	read.h	105;"	d
redisReaderGetObject	read.h	104;"	d
redisReaderGetReply	read.cpp	/^int redisReaderGetReply(redisReader *r, void **reply) {$/;"	f
redisReaderSetPrivdata	read.h	103;"	d
redisReconnect	hiredis.cpp	/^int redisReconnect(redisContext *c) {$/;"	f
redisReply	hiredis.h	/^typedef struct redisReply {$/;"	s
redisReply	hiredis.h	/^} redisReply;$/;"	t	typeref:struct:redisReply
redisReplyObjectFunctions	read.h	/^typedef struct redisReplyObjectFunctions {$/;"	s
redisReplyObjectFunctions	read.h	/^} redisReplyObjectFunctions;$/;"	t	typeref:struct:redisReplyObjectFunctions
redisSetBlocking	net.cpp	/^static int redisSetBlocking(redisContext *c, int blocking) {$/;"	f	file:
redisSetReuseAddr	net.cpp	/^static int redisSetReuseAddr(redisContext *c) {$/;"	f	file:
redisSetTcpNoDelay	net.cpp	/^static int redisSetTcpNoDelay(redisContext *c) {$/;"	f	file:
redisSetTimeout	hiredis.cpp	/^int redisSetTimeout(redisContext *c, const struct timeval tv) {$/;"	f
redisvAppendCommand	hiredis.cpp	/^int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {$/;"	f
redisvAsyncCommand	async.cpp	/^int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap) {$/;"	f
redisvCommand	hiredis.cpp	/^void *redisvCommand(redisContext *c, const char *format, va_list ap) {$/;"	f
redisvFormatCommand	hiredis.cpp	/^int redisvFormatCommand(char **target, const char *format, va_list ap) {$/;"	f
removeAllSlaveNode	redisNode.cpp	/^		void RedisCommonNode::removeAllSlaveNode()$/;"	f	class:goddard::RedisCommonNode
replies	async.h	/^    redisCallbackList replies;$/;"	m	struct:redisAsyncContext
reply	read.h	/^    void *reply; \/* Temporary reply pointer *\/$/;"	m	struct:redisReader
reset	redisCluster.h	/^						void reset()$/;"	f	class:goddard::RedisCluster
reset	redisCluster.h	/^						void reset()$/;"	f	class:goddard::RedisClusterItem
reset	redisConfig.h	/^				void reset()$/;"	f	struct:goddard::stRedisConfigItem
reset	redisNode.cpp	/^		void RedisClusterNode::reset(const std::string &ip, const uint32_t port, const std::string &passwd)$/;"	f	class:goddard::RedisClusterNode
reset	redisNode.h	/^						virtual void reset(const std::string &ip = "", const uint32_t port = 0, const std::string &passwd = "")$/;"	f	class:goddard::RedisCommonNode
reset	redisNode.h	/^						void reset(RedisClusterNode *node = NULL, uint32_t slot = (uint32_t)-1)$/;"	f	class:goddard::RedisSlotNode
reset	redisSingle.h	/^						void reset()$/;"	f	class:goddard::RedisSingle
ridx	read.h	/^    int ridx; \/* Index of current read task *\/$/;"	m	struct:redisReader
rstack	read.h	/^    redisReadTask rstack[9];$/;"	m	struct:redisReader
s_free	sdsalloc.h	42;"	d
s_malloc	sdsalloc.h	40;"	d
s_realloc	sdsalloc.h	41;"	d
sds	sds.h	/^typedef char *sds;$/;"	t
sdsAllocPtr	sds.cpp	/^void *sdsAllocPtr(sds s) {$/;"	f
sdsAllocSize	sds.cpp	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsHdrSize	sds.cpp	/^static inline int sdsHdrSize(char type) {$/;"	f	file:
sdsIncrLen	sds.cpp	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	sds.cpp	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	sds.cpp	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsReqType	sds.cpp	/^static inline char sdsReqType(size_t string_size) {$/;"	f	file:
sdsTest	sds.cpp	/^int sdsTest(void) {$/;"	f
sds_free	sds.cpp	/^void sds_free(void *ptr) { s_free(ptr); }$/;"	f
sds_malloc	sds.cpp	/^void *sds_malloc(size_t size) { return s_malloc(size); }$/;"	f
sds_realloc	sds.cpp	/^void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }$/;"	f
sdsalloc	sds.h	/^static inline size_t sdsalloc(const sds s) {$/;"	f
sdsavail	sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	sds.cpp	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatfmt	sds.cpp	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f
sdscatlen	sds.cpp	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	sds.cpp	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	sds.cpp	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	sds.cpp	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	sds.cpp	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	sds.cpp	/^void sdsclear(sds s) {$/;"	f
sdscmp	sds.cpp	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	sds.cpp	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	sds.cpp	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	sds.cpp	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	sds.cpp	/^sds sdsempty(void) {$/;"	f
sdsfree	sds.cpp	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	sds.cpp	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	sds.cpp	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	sds.cpp	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr16	sds.h	/^struct __attribute__ ((__packed__)) sdshdr16 {$/;"	s
sdshdr32	sds.h	/^struct __attribute__ ((__packed__)) sdshdr32 {$/;"	s
sdshdr5	sds.h	/^struct __attribute__ ((__packed__)) sdshdr5 {$/;"	s
sdshdr64	sds.h	/^struct __attribute__ ((__packed__)) sdshdr64 {$/;"	s
sdshdr8	sds.h	/^struct __attribute__ ((__packed__)) sdshdr8 {$/;"	s
sdsinclen	sds.h	/^static inline void sdsinclen(sds s, size_t inc) {$/;"	f
sdsjoin	sds.cpp	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdsjoinsds	sds.cpp	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {$/;"	f
sdslen	sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsll2str	sds.cpp	/^int sdsll2str(char *s, long long value) {$/;"	f
sdsmapchars	sds.cpp	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	sds.cpp	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	sds.cpp	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	sds.cpp	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssetalloc	sds.h	/^static inline void sdssetalloc(sds s, size_t newlen) {$/;"	f
sdssetlen	sds.h	/^static inline void sdssetlen(sds s, size_t newlen) {$/;"	f
sdssplitargs	sds.cpp	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	sds.cpp	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	sds.cpp	/^void sdstolower(sds s) {$/;"	f
sdstoupper	sds.cpp	/^void sdstoupper(sds s) {$/;"	f
sdstrim	sds.cpp	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsull2str	sds.cpp	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f
sdsupdatelen	sds.cpp	/^void sdsupdatelen(sds s) {$/;"	f
seekNewline	read.cpp	/^static char *seekNewline(char *s, size_t len) {$/;"	f	file:
setConfig	redisCommon.h	/^						void setConfig(const RedisConfig *config)$/;"	f	class:goddard::RedisCommon
setOwner	redisCluster.cpp	/^		void RedisClusterItem::setOwner(RedisCluster *owner)$/;"	f	class:goddard::RedisClusterItem
setOwner	redisNode.h	/^						void setOwner(RedisCommon *owner)$/;"	f	class:goddard::RedisCommonNode
setSlotNode	redisCluster.h	/^						void setSlotNode(RedisClusterNode *node, uint32_t slotIdx)$/;"	f	class:goddard::RedisCluster
size	dict.h	/^    unsigned long size;$/;"	m	struct:dict
sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	struct:dict
snprintf	win32.h	14;"	d
source_addr	hiredis.h	/^        char *source_addr;$/;"	m	struct:redisContext::__anon3
stRedisConfigItem	redisConfig.h	/^				stRedisConfigItem()$/;"	f	struct:goddard::stRedisConfigItem
stRedisConfigItem	redisConfig.h	/^		struct stRedisConfigItem$/;"	s	namespace:goddard
start	redisCluster.cpp	/^		bool RedisCluster::start()$/;"	f	class:goddard::RedisCluster
start	redisSingle.h	/^						virtual bool start()$/;"	f	class:goddard::RedisSingle
str	hiredis.h	/^    char *str; \/* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING *\/$/;"	m	struct:redisReply
sub	async.h	/^    } sub;$/;"	m	struct:redisAsyncContext	typeref:struct:redisAsyncContext::__anon2
table	dict.h	/^    dictEntry **table;$/;"	m	struct:dict
tail	async.h	/^    redisCallback *head, *tail;$/;"	m	struct:redisCallbackList
tcp	hiredis.h	/^    } tcp;$/;"	m	struct:redisContext	typeref:struct:redisContext::__anon3
timeout	hiredis.h	/^    struct timeval *timeout;$/;"	m	struct:redisContext	typeref:struct:redisContext::timeval
type	dict.h	/^    dictType *type;$/;"	m	struct:dict
type	hiredis.h	/^    int type; \/* REDIS_REPLY_* *\/$/;"	m	struct:redisReply
type	read.h	/^    int type;$/;"	m	struct:redisReadTask
unix_sock	hiredis.h	/^    } unix_sock;$/;"	m	struct:redisContext	typeref:struct:redisContext::__anon4
used	dict.h	/^    unsigned long used;$/;"	m	struct:dict
va_copy	win32.h	10;"	d
val	dict.h	/^    void *val;$/;"	m	struct:dictEntry
valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType
valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType
~RedisCluster	redisCluster.h	/^						virtual ~RedisCluster()$/;"	f	class:goddard::RedisCluster
~RedisClusterItem	redisCluster.h	/^						~RedisClusterItem()$/;"	f	class:goddard::RedisClusterItem
~RedisClusterNode	redisNode.h	/^						~RedisClusterNode()$/;"	f	class:goddard::RedisClusterNode
~RedisCommon	redisCommon.h	/^						virtual ~RedisCommon()$/;"	f	class:goddard::RedisCommon
~RedisCommonNode	redisNode.h	/^						virtual ~RedisCommonNode()$/;"	f	class:goddard::RedisCommonNode
